<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kick TTS</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"
      integrity="sha512-xi/RZRIF/S0hJ+yJJYuZ5yk6/8pCiRlEXZzoguSMl+vk2i3m6UjUO/WcZ11blRL/O+rnj94JRGwt/CHbc9+6EA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <body>
    <div id="video"></div>
    <script>
      const kickObsTTSSettings = "kick-obs-tts-settings";

      const defaultClusterID = "32cbd69e4b950bf97679";
      const defaultVersion = "8.4.0-rc2";
      const defaultRefreshToken = "refreshTTS";
      const defaultTtsVoice = "Brian";

      let settings = {
        roomID: undefined,

        clusterID: defaultClusterID,

        version: defaultVersion,

        refreshToken: defaultRefreshToken,

        ttsVoice: defaultTtsVoice,

        ttsSpeed: 1.0,

        ttsVolume: 1.0,

        journey: undefined,

        admins: [],
      };

      let state = {
        ws: undefined,
        ttsQueue: [],
        currentAudio: undefined,
      };

      function applyOverrides(target, source) {
        const settings = Object.assign({}, target);

        Object.entries(source).forEach(([key, value]) => {
          if (value != null && value != "") {
            settings[key] = value;
          }
        });

        return settings;
      }

      function loadSettings() {
        const urlParams = new URLSearchParams(window.location.search);
        const roomID = urlParams.get("roomId");
        const storageKey = `${kickObsTTSSettings}-${roomID}`;

        const localStorageSettings =
          JSON.parse(localStorage.getItem(storageKey)) || {};

        const urlSettings = {
          roomID,
          clusterID: urlParams.get("clusterID"),
          version: urlParams.get("version"),
          refreshToken: urlParams.get("refreshToken"),
          ttsVoice: urlParams.get("ttsVoice"),
          admins:
            urlParams
              .get("admins")
              ?.split(",")
              .map((admin) => admin.toLowerCase()) || [],
          journey: urlParams.get("journey"),
        };

        const ttsSpeed = parseFloat(urlParams.get("ttsSpeed"));
        const ttsVolume = parseFloat(urlParams.get("ttsVolume"));

        if (!Number.isNaN(ttsSpeed)) {
          urlSettings.ttsSpeed = ttsSpeed;
        }

        if (!Number.isNaN(ttsVolume)) {
          urlSettings.ttsVolume = ttsVolume;
        }

        settings = applyOverrides(settings, urlSettings);
        settings = applyOverrides(settings, localStorageSettings);
      }

      function saveSettings() {
        const roomID = settings.roomID;
        localStorage.setItem(
          `${kickObsTTSSettings}-${roomID}`,
          JSON.stringify(settings)
        );

        console.log("Settings saved to localStorage.");
      }

      function clearStoredSettings() {
        const roomID = settings.roomID;
        localStorage.setItem(
          `${kickObsTTSSettings}-${roomID}`,
          JSON.stringify(settings)
        );

        console.log("Stored settings cleared from localStorage.");
      }

      function enqueMessage(text, { voice = defaultTtsVoice }) {
        const { ttsQueue } = state;
        ttsQueue.push({ text, voice });

        if (ttsQueue.length == 1) {
          fetchAndPlayTTS();
        }
      }

      async function fetchAndPlayTTS() {
        const { ttsQueue } = state;
        if (ttsQueue.length == 0) {
          return;
        }

        const { journey, ttsVolume, ttsSpeed } = settings;

        // peek at the first message in the queue
        const { voice, text } = ttsQueue[0];

        try {
          let ttsUrl;

          if ((voice === "Spanish" || voice === "French") && journey) {
            ttsUrl = `https://${journey}.cloudfunctions.net/tts?text=${encodeURIComponent(
              text
            )}&lang=${voice}`;
          } else {
            ttsUrl = `https://api.streamelements.com/kappa/v2/speech?voice=${voice}&text=${encodeURIComponent(
              text
            )}`;
          }

          // Fetch the audio response from the API
          const response = await fetch(ttsUrl);
          const audioBuffer = await response.arrayBuffer();

          const base64 = btoa(
            String.fromCharCode(...new Uint8Array(audioBuffer))
          );

          const audioText = `data:audio/${
            voice === "French" || voice === "Spanish" ? "ogg" : "mp3"
          };base64,${base64}`;

          const audio = new Howl({
            src: [audioText],
          });

          state.currentAudio = audio;
          audio.volume(ttsVolume);
          audio.rate(ttsSpeed);

          audio.on("end", function () {
            // deque the first messages in the queue
            ttsQueue.shift();

            state.currentAudio = null;

            // yield back to the queue
            fetchAndPlayTTS();
          });

          function audioError(id, error) {
            console.error("Error fetching TTS:", error);
            ttsQueue.shift();
            state.currentAudio = null;
            fetchAndPlayTTS();
          }

          audio.on("loaderror", audioError);
          audio.on("playerror", audioError);

          // Play the audio
          audio.play();
        } catch (error) {
          console.error("Error fetching TTS:", error);

          // skip to next message
          ttsQueue.shift();

          state.currentAudio = null;

          fetchAndPlayTTS();
        }
      }

      function playVideo(videoURL) {
        const vidContainer = document.getElementById("video");
        const iframe = document.createElement("iframe");

        iframe.width = "560";
        iframe.height = "315";
        iframe.src = videoURL;
        iframe.title = "video player";
        iframe.frameBorder = "0";
        iframe.allow =
          "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share";
        iframe.allowFullscreen = true;

        vidContainer.appendChild(iframe);
      }

      function clearVideos() {
        document.getElementById("video").innerHTML = "";
      }

      function connectToChatroom(settings, state) {
        const { clusterID, version, roomID, admins, ttsVoice, refreshToken } =
          settings;

        state.ws = new WebSocket(
          `wss://ws-us2.pusher.com/app/${clusterID}?protocol=7&client=js&version=${version}&flash=false`
        );

        const { ws, ttsQueue } = state;

        ws.onopen = () => {
          console.log("Connected to WebSocket");

          const subscribeMessage = {
            event: "pusher:subscribe",
            data: {
              channel: `chatrooms.${roomID}.v2`,
              auth: "",
            },
          };
          ws.send(JSON.stringify(subscribeMessage));

          if (ttsQueue.length > 0) {
            fetchAndPlayTTS();
          }
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);

            // Check if the message is a chat message event
            if (message.event === "App\\Events\\ChatMessageEvent") {
              const chatMessage = JSON.parse(message.data);

              const senderUsername = chatMessage?.sender?.slug;

              const isAdmin = admins.includes(senderUsername);

              console.log("Received chat message:", chatMessage.content);

              // trigger an app refresh
              if (isAdmin && chatMessage.content === refreshToken) {
                location.reload();
              }

              if (isAdmin && chatMessage.content == "!skip") {
                const { currentAudio } = state;

                // this is how you trigger the audio to end and not just stop
                currentAudio.seek(currentAudio.duration());

                return;
              }

              // Use speech synthesis to read the message aloud
              if (chatMessage.content.startsWith("!s ")) {
                const voiceTokenRegex = /^!s\s*(\w+):/;
                const tokenVoiceMatch =
                  chatMessage.content.match(voiceTokenRegex);
                const voiceToken = tokenVoiceMatch
                  ? tokenVoiceMatch[1]
                  : undefined;

                const voice = voiceToken
                  ? voiceToken[0].toUpperCase() +
                    voiceToken.slice(1).toLowerCase()
                  : undefined;

                const cleanedString = chatMessage.content
                  .replace(voiceTokenRegex, "") // remove voice tokens
                  .replace(/^!s\s*/, "") // Removes "!s" prefix if present
                  .replace(/\[emote:[^\]]+:[^\]]+\]/g, ""); // Removes [emote:*:*] patterns

                enqueMessage(cleanedString, { voice: voice ?? ttsVoice });
              }

              // update Volume
              if (isAdmin && chatMessage.content.startsWith("!v ")) {
                const volVal = Number(parseFloat(chatMessage.content.slice(3)));

                if (!Number.isNaN(volVal) && volVal >= 0 && volVal <= 1) {
                  settings.ttsVolume = volVal;
                }
              }

              // streamable
              if (isAdmin && chatMessage.content.startsWith("!st ")) {
                if (chatMessage.content.slice(4) == "clear") {
                  clearVideos();
                  return;
                }

                const streamableRegex =
                  /(?:https?:\/\/)?streamable\.com\/([a-zA-Z0-9]+)/;

                const streamableMatch =
                  chatMessage.content.match(streamableRegex);

                const streamableId = streamableMatch
                  ? streamableMatch[1]
                  : undefined;

                if (streamableId) {
                  const streamableURL = `https://streamable.com/e/${streamableId}?autoplay=1&loop=0`;
                  playVideo(streamableURL);
                }
              }

              // youtube
              if (isAdmin && chatMessage.content.startsWith("!yt ")) {
                // clear all videos
                if (chatMessage.content.slice(4) == "clear") {
                  clearVideos();
                  return;
                }

                const youtubeRegex =
                  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/;
                const youtubeMatch = chatMessage.content.match(youtubeRegex);

                const youtubeId = youtubeMatch ? youtubeMatch[1] : undefined;

                if (youtubeId) {
                  let youtubeURL = `https://www.youtube.com/embed/${youtubeId}?autoplay=1`;

                  playVideo(youtubeURL);
                }
              }

              // config management
              if (isAdmin && chatMessage.content.startsWith("!config ")) {
                const tokens = chatMessage.content.slice(8).split(" ");

                if (tokens.length < 2) {
                  return;
                }

                const [key, value] = tokens;

                if (key === "removeadmin" || key === "addadmin") {
                  const user = value.toLowerCase();

                  if (key === "removeadmin") {
                    const i = admins.indexOf(user);

                    if (i >= 0 && user !== "cheesypotatoe") {
                      admins.splice(i, 1);
                    }
                  } else {
                    // addadmin

                    admins.push(user);
                  }
                } else {
                  const [key, value] = tokens;

                  if (state.hasOwnProperty(key)) {
                    state[key] = value;
                  }
                }

                ws.close();
              }

              if (isAdmin && chatMessage.content.startsWith("!speed ")) {
                const sp = parseFloat(chatMessage.content.slice(7));

                if (!Number.isNaN(sp)) {
                  settings.ttsSpeed = sp;
                }
              }

              if (isAdmin && chatMessage.content === "!save") {
                saveSettings();
              }

              if (isAdmin && chatMessage.content === "!clear") {
                clearStoredSettings();
              }
            }

            if (message.event === "pusher:error") {
              console.error(
                "Received Error Message: ",
                JSON.parse(message.data)
              );
            }
          } catch (error) {
            console.error("Error parsing message:", error);
          }
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        ws.onclose = () => {
          console.log("WebSocket connection closed");

          console.log("Reconnecting...");

          setTimeout(connect, 1000 * 2);
        };
      }

      // Get parameters from URL (roomId, clusterID, version)
      loadSettings();

      function connect() {
        connectToChatroom(settings, state);
      }

      if (!settings.roomID) {
        console.error("Missing room Id");
      } else {
        connect();
      }
    </script>
  </body>
</html>
